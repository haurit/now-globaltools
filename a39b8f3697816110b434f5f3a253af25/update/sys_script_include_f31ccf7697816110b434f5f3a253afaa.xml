<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.GlobalTools</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Tools to support (scoped) app development&#13;
Functions are only available for global scope and specific scopes defined in the system properties "now.globaltools.access_from_scope" or "now.globaltools.access_from_scope_custom" for security reasons.</description>
        <name>GlobalTools</name>
        <script><![CDATA[var GlobalTools = Class.create();
GlobalTools.prototype = {
	initialize: function () {
		this._unique = new global.GlobalToolsArray().unique;
	}, // function initialize

	checkAccess: function () {
		var sCallerScope = gs.getCallerScopeName();
		var aScopes = String(gs.getProperty('now.globaltools.access_from_scope')).split(',');
		var aCustomScopes = String(gs.getProperty('now.globaltools.access_from_scope_custom')).split(',');
		if ((sCallerScope) && ((sCallerScope == 'rhino.global') || (aScopes.indexOf(sCallerScope) != -1) || (aCustomScopes.indexOf(sCallerScope) != -1))) {
			return true;
		} // if scope is allowed
	}, // function checkAccess

	// Substitute null values in simple types
	// DEPRECATED: sObjKey --> use GlobalToolsObject.getValue instead!
	nsub: function (sValue, sSubstitute, sType, sObjKey) {
		if (!this.checkAccess()) { return; }
		if (sObjKey) {
			if (sValue.hasOwnProperty(sObjKey)) {
				sValue = sValue[sObjKey];
			} else {
				sValue = null;
			} // if has property
		} // if obj and objkey
		sType = (sType) ? sType : this.getType(sValue);
		var sSubstituteType = this.getType(sSubstitute);
		if ((sValue) || (sValue === false) || (sValue === 0)) {
			if ((sType == 'array') || (Array.isArray(sSubstitute))) {
				if (Array.isArray(sValue)) {
					return sValue;
				} else {
					return sValue.split(',');
				} // if is array
			} else if (sType == 'number') {
				return sValue;
			} else if ((sType == 'object') || (sSubstituteType == 'object')) {
				return sValue;
			} else if ((sType == 'boolean') || ((sSubstitute === true || sSubstitute === false || sSubstituteType === 'boolean'))) {
				return Boolean(sValue);
			} else {
				return String(sValue);
			} // if array, bool, string
		} else if (((sSubstitute !== undefined)) && (sSubstitute !== null)) {
			if (sType == 'string') {
				return String(sSubstitute);
			} else {
				return sSubstitute;
			} // if force string
		} else {
			if (sType == 'array') {
				return [];
			} else if (sType == 'object') {
				return {};
			} else if (sType == 'number') {
				return -1;
			} else if (sType == 'boolean') {
				return false;
			} else {
				return '';
			} // if array
		} // if value
	}, // function nsub

	getType: function (oValue, bDoNotConvertCase) {
		if (!this.checkAccess()) { return; }
		if (oValue === null) {
			return 'null';
		}
		var sType = typeof oValue;
		if (sType == 'object') {
			var sObjectType = String(Object.prototype.toString.call(oValue));
			var aType = sObjectType.match(/^\[object\s(.*)\]$/);
			sType = ((aType) && (Array.isArray(aType)) && (aType.length > 0)) ? aType[1] : '';
			if (sType == 'JavaObject') {
				var sJavaClassName = GlideJSUtil.getJavaClassName(oValue);
				if (sJavaClassName) {
					sType = sJavaClassName.substring(sJavaClassName.lastIndexOf('.') + 1);
				} // if java class name
			} // if java object
			if (sType) {
				return (bDoNotConvertCase) ? sType : String(sType).toLowerCase();
			} // if type
		} // if obj
		return sType;
	}, // function getType

	isEqual: function (oValue1, oValue2) {
		if (((oValue1) && (!oValue2)) || ((!oValue1) && (oValue2))) {
			return false;
		} else if ((!oValue1) && (!oValue2)) {
			return true;
		} // if one is empty or both
		var sValue1Type = this.getType(oValue1);
		var sValue2Type = this.getType(oValue2);
		if (sValue1Type != sValue2Type) {
			return false;
		} else if (sValue1Type == 'array') {
			if (oValue1.length !== oValue2.length) {
				return false;
			} // if not same length
			oValue1.sort();
			oValue2.sort();
			return (String(oValue1) == String(oValue2));
		} else if (sValue1Type == 'object') {
			var aKeys1 = Object.keys(oValue1);
			var aKeys2 = Object.keys(oValue2);
			if (aKeys1.length !== aKeys2.length) {
				return false;
			} // if not same keys length
			if (!this.isEqual(aKeys1, aKeys2)) {
				return false;
			} // if not same keys
			var bDifferent = false;
			aKeys1.some(function (sKey) {
				if (!this.isEqual(oValue1[sKey], oValue2[sKey])) {
					bDifferent = true;
					return true;
				} // if not same keys
			}, this); // some keys
			if (bDifferent) {
				return false;
			} else {
				return true;
			} // if different
		} // if not same type, array or obj
		if ((sValue1Type == 'string') && (sValue1Type == 'string')) {
			return String(oValue1) == String(oValue2);
		} // if string convert to overcome character set issues
		return oValue1 === oValue2;
	}, // function isEqual

	// Encode new line to tag
	encodeNewLineToTag: function (sValue) {
		if (!this.checkAccess()) { return; }
		var sResult = (sValue) ? String(sValue).replace(/\n/g, '!^br^!') : '';
		return sResult;
	}, // function encodeNewLineToTag

	// Decode tag to new line
	decodeTagToNewLine: function (sValue) {
		if (!this.checkAccess()) { return; }
		var sResult = String(sValue).replace(/!\^br\^!/g, '\n');
		return sResult;
	}, // function decodeTagToNewLine

	// Function to replace placeholders
	replacePlaceholders: function(sInputValue, oRecord, sValue, bJSON) {
		if ((sInputValue) && (oRecord)) {
			var bIsRecord = (this.getType(oRecord).indexOf('gliderecord') != -1);
			var reGetFields = /(\[[A-Za-z_0-9]*\])(?!.*")/gi;
			if (this.getType(sInputValue) == 'object') {
				sInputValue = JSON.stringify(sInputValue);
				bJSON = true;
			} // if object
			if (bJSON) {
				reGetFields = /(\[[A-Za-z_0-9]*\])/gi;
			} // if json
			var aReResults = String(sInputValue).match(reGetFields);
			var reReplace = new RegExp('placeholder'); 
			var sFieldName = '', sReplaceValue = '', sReplace = '';
			if ((aReResults) && (Array.isArray(aReResults))) {
				this._unique(aReResults);
				aReResults.forEach(function(sReResult) {
					sFieldName = sReResult.replace(/\[|\]/g, '');
					if (sFieldName == 'sValue') {
						sReplaceValue = sValue;
					} else if (bIsRecord) {
						sReplaceValue = oRecord.getValue(sFieldName);
					} else {
						sReplaceValue = oRecord[sFieldName];
					} // if fieldname is value
					if (sReplaceValue) {
						sReplace = sReResult.replace('[', '\\[').replace(']', '\\]');
						reReplace = new RegExp(sReplace, 'gi');
						sInputValue = sInputValue.replace(reReplace, sReplaceValue);
					} // if value
				}, this); // each re result
			} // if reResult
		} // if input 
		return sInputValue;
	}, // function replacePlaceholders

	convertUnderscoretoCamelCase: function(sInputValue) {
        if (sInputValue) {
            var aResult = [];
            sInputValue.split('_').forEach(function(sWord) {
                sWord = sWord.replace(/[^a-zA-Z0-9]/g, '');
                aResult.push(sWord.charAt(0).toUpperCase() + sWord.substr(1).toLowerCase());
            }); // each word
            return aResult.join('');
        } // if name
        return sInputValue;
    }, // function convertUnderscoretoCamelCase

	// Schedule ScriptInclude Function
	scheduleScript: function (sScriptInclude, sFunction, iSeconds, aFunctionArgs, aClassArgs, sScheduleName) {
		if (!this.checkAccess()) { return; }
		function parseArgs(aArgs) {
			var aReturn = [];
			if (!aArgs) {
				return '';
			} // if no args
			aArgs.forEach(function (oItem, iIndex) {
				var sType = typeof oItem;
				if ((!oItem) && (sType != 'boolean') && (!oItem === 0)) {
					return '';
				} // if empty
				if (JSUtil.instance_of(oItem, GlideRecord)) {
					aScript.push('var grRecord_' + iIndex + " = new GlideRecord('" + oItem.getTableName() + "');");
					aScript.push('grRecord_' + iIndex + ".get('" + oItem.getUniqueValue() + "');");
					aReturn.push('grRecord_' + iIndex);
				} else if (JSUtil.instance_of(oItem, GlideDate)) {
					aScript.push('var dtDate_' + iIndex + " = new GlideDate('" + oItem + "');");
					aReturn.push('dtDate_' + iIndex);
				} else if (JSUtil.instance_of(oItem, GlideTime)) {
					aScript.push('var dtTime_' + iIndex + " = new GlideTime('" + oItem + "');");
					aReturn.push('dtTime_' + iIndex);
				} else if (JSUtil.instance_of(oItem, GlideDateTime)) {
					aScript.push('var dtDateTime_' + iIndex + " = new GlideDateTime('" + oItem + "');");
					aReturn.push('dtDateTime_' + iIndex);
				} else {
					aReturn.push(JSON.stringify(oItem));
				} // if special object
			}, this); // each argument
			return aReturn.join(', ');
		} // function parseArgs
		iSeconds = (iSeconds) ? iSeconds : 1;
		var sScriptName = '';
		var bCalcScript = true;
		var aScript = [];
		if (Array.isArray(sScriptInclude)) {
			sScriptName = (sFunction) ? sFunction : 'Passed Script';
			bCalcScript = false;
			aScript = sScriptInclude;
		} // if is array
		if (bCalcScript) {
			var sClassArgs = (aClassArgs) ? parseArgs(aClassArgs) : '';
			var sFunctionArgs = (aFunctionArgs) ? parseArgs(aFunctionArgs) : '';
			sScriptName = 'GlobalTools.scheduleScript - ' + sScriptInclude + '.' + sFunction;
			aScript.push('new ' + sScriptInclude + '(' + sClassArgs + ').' + sFunction + '(' + sFunctionArgs + ');');
		} // if bCalcScript
		var dtDelay = new GlideDateTime();
		dtDelay.addSeconds(iSeconds);
		sScheduleName = (sScheduleName) ? sScheduleName : 'GlobalTools.ScriptScheduler - ' + sScriptName;
		var grTrigger = new GlideRecord('sys_trigger');
		grTrigger.newRecord();
		grTrigger.setValue('name', sScheduleName);
		grTrigger.setValue('trigger_type', '0');
		grTrigger.setValue('next_action', dtDelay);
		grTrigger.setValue('script', aScript.join('\n'));
		return grTrigger.insert();
	}, // function scheduleScript

	// Convenience function to handle scheduler
	scheduleHandler: function (sEvent, sDelaySeconds, sAction, sAddlQuery, grRecord, oParam1, oParam2, sQueue) {
		if (!this.checkAccess()) { return; }
		try {
			if (!sEvent) {
				gs.warn('global.GlobalTools.scheduleHandler called without an event.');
				return false;
			} // if not event return
			sAddlQuery = (sAddlQuery) ? '^' + sAddlQuery : '';
			grRecord = (grRecord) ? grRecord : '';
			oParam1 = (oParam1) ? String(oParam1) : '';
			oParam2 = (oParam2) ? String(oParam2) : '';
			sQueue = (sQueue) ? sQueue : '';
			var grEvent = new GlideRecord('sysevent');
			grEvent.addQuery('stateNOT INprocessed,error^name=' + sEvent + sAddlQuery);
			grEvent.query();
			if (sAction == 'stop') {
				while (grEvent.next()) {
					grEvent.setValue('processed', gs.daysAgo(0));
					grEvent.setValue('state', 'processed');
					grEvent.setValue('processing_duration', 0);
					grEvent.setWorkflow(false);
					grEvent.update();
				} // disable active events
			} else if (!grEvent.next()) {
				if ((sDelaySeconds) && (!isNaN(sDelaySeconds))) {
					var dtSchedule = new GlideDateTime();
					dtSchedule.addSeconds(sDelaySeconds);
					gs.eventQueueScheduled(sEvent, grRecord, oParam1, oParam2, dtSchedule);
				} else {
					gs.eventQueue(sEvent, grRecord, oParam1, oParam2, sQueue);
				} // if delay
			} // if action
		} catch (oExeption) {
			gs.warn('global.GlobalTools.scheduleHandler Exception during schedule sEvent: ' + sEvent, oExeption);
		} // catch errors
	}, // function scheduleHandler

	// Overcome scopeing issue
	sleep: function (iMilliseconds) {
		if (!this.checkAccess()) { return; }
		gs.sleep(iMilliseconds);
	}, // function sleep

	// Run function in a same scope
	runFunction: function (sFunction) { // function is a <script_include>.<function>.toString(), 2nd... args will be evaluated in function call
		if (!this.checkAccess()) { return; }
		var gsEvaluator = new GlideScopedEvaluator();
		gsEvaluator.putVariable('result', null);
		var aArguments = [];
		for (var i = 1; i < arguments.length; i++) {
			gsEvaluator.putVariable('param_' + String(i), arguments[i]);
			aArguments.push('param_' + String(i));
		} // each argument after script and scope
		sFunction = sFunction.replace('function (', 'function tempname(');
		sFunction = 'result = tempname(' + aArguments.join(',') + ');\n' + sFunction;
		var grScriptInclude = new GlideRecord('sys_script_include');
		if (grScriptInclude.get('name', 'GlobalTools')) {
			grScriptInclude.setValue('script', sFunction);
			try {
				var _oResult = gsEvaluator.evaluateScript(grScriptInclude, 'script'); // glide eval insists on a "queried" record
				var oResult = gsEvaluator.getVariable('result');
				return oResult;
			} catch (ex) {
				gs.error('GlobalTools.runFunctionInScope is had an error: ' + String(ex));
			} // catch error in code
		} // if script include
	}, // runFunction

	// Run function in a specific scope (please note the function may only use valid scoped features)
	runFunctionInScope: function (sFunction, sScopeId) { // function is a <script_include>.<function>.toString(), 3rd... args will be evaluated in function call
		if (!this.checkAccess()) { return; }
		if (gs.getProperty('glide.record.legacy_cross_scope_access_policy_in_script') == 'true') {
			gs.warn('GlobalTools.runFunctionInScope is allowed, please validate your instance security settings!');
			var gsEvaluator = new GlideScopedEvaluator();
			gsEvaluator.putVariable('result', null);
			var aArguments = [];
			for (var i = 2; i < arguments.length; i++) {
				gsEvaluator.putVariable('param_' + String(i), arguments[i]);
				aArguments.push('param_' + String(i));
			} // each argument after script and scope
			sFunction = sFunction.replace('function (', 'function tempname(');
			sFunction = 'result = tempname(' + aArguments.join(',') + ');\n' + sFunction;
			var grScriptInclude = new GlideRecord('sys_script_include');
			if (grScriptInclude.get('name', 'GlobalTools')) {
				grScriptInclude.setValue('sys_scope', sScopeId);
				grScriptInclude.setValue('script', sFunction);
				try {
					var vResult = gsEvaluator.evaluateScript(grScriptInclude, 'script'); // glide eval insists on a "queried" record
					var oResult = gsEvaluator.getVariable('result');
					return oResult;
				} catch (ex) {
					gs.error('GlobalTools.runFunctionInScope is had an error: ' + String(ex));
				} // catch error in code
			} // if script include
		} else {
			gs.warn('GlobalTools.runFunctionInScope is not allowed in a secured instances!');
		} // if legacy scope script policy is true
	}, // runFunctionInScope

	type: 'GlobalTools',
	version: '1.0.1',
	author: 'Tom Hauri',
	email: 'tom@hauri.biz'

};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>tom.hauri</sys_created_by>
        <sys_created_on>2023-02-20 09:05:58</sys_created_on>
        <sys_id>f31ccf7697816110b434f5f3a253afaa</sys_id>
        <sys_mod_count>97</sys_mod_count>
        <sys_name>GlobalTools</sys_name>
        <sys_package display_value="Global Tools" source="a39b8f3697816110b434f5f3a253af25">a39b8f3697816110b434f5f3a253af25</sys_package>
        <sys_policy/>
        <sys_scope display_value="Global Tools">a39b8f3697816110b434f5f3a253af25</sys_scope>
        <sys_update_name>sys_script_include_f31ccf7697816110b434f5f3a253afaa</sys_update_name>
        <sys_updated_by>tom.hauri</sys_updated_by>
        <sys_updated_on>2023-11-22 05:45:14</sys_updated_on>
    </sys_script_include>
</record_update>
