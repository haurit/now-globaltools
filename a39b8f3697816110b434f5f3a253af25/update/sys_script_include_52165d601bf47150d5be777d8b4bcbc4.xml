<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.GlobalToolsObject</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Tools to support (scoped) app development&#13;
Functions are only available for global scope and specific scopes defined in the system properties "now.globaltools.access_from_scope" or "now.globaltools.access_from_scope_custom" for security reasons.&#13;
From Vancouver release onwards you can use GlideJsonPathAPI instead of getValue function.&#13;
https://docs.servicenow.com/en-US/bundle/vancouver-api-reference/page/app-store/dev_portal/API_reference/GlideJsonPath/concept/GlideJsonPathAPI.html&#13;
&#13;
If your script is in ECMA 6 mode use Object.assign instead of ObjectAssign function.</description>
        <mobile_callable>false</mobile_callable>
        <name>GlobalToolsObject</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[var GlobalToolsObject = Class.create();
GlobalToolsObject.prototype = {
	initialize: function () {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		this._gt = new global.GlobalTools();
		this._gtArray = new global.GlobalToolsArray();
	}, // function initialize

	checkAccess: function (sCallerScope) {
		var aScopes = String(gs.getProperty('now.globaltools.access_from_scope')).split(',');
		var aCustomScopes = String(gs.getProperty('now.globaltools.access_from_scope_custom')).split(',');
		if ((sCallerScope) && ((sCallerScope == 'rhino.global') || (aScopes.indexOf(sCallerScope) != -1) || (aCustomScopes.indexOf(sCallerScope) != -1))) {
			return true;
		} // if scope is allowed
	}, // function checkAccess

	// Function to check if it is an object, use GlobalTools.getType to distinuish different object types
	isObject: function (oObj) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if ((oObj) && (typeof oObj === 'object') && (!Array.isArray(oObj))) {
			return true;
		} // if obj
	}, // function isObject

	// Function to retrieve value from object via config path with replace
	getValue: function (sConfigPath, sReplace, oConfig) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if ((!sConfigPath) || (!oConfig)) {
			return sReplace;
		} // if no path or object
		sConfigPath = sConfigPath.replace(/^\//, '').replace(/\/$/, ''); // remove leading and trailing /
		var aConfigPath = sConfigPath.split('/');
		var iMaxLength = (Array.isArray(aConfigPath)) ? aConfigPath.length : 0;
		if (iMaxLength === 0) {
			return sReplace;
		} // if no item
		var oCurrent = oConfig;
		for (var i = 0; i < iMaxLength; i++) {
			if (gs.nil(oCurrent[aConfigPath[i]])) {
				return sReplace;
			} // if nil at this level
			oCurrent = oCurrent[aConfigPath[i]];
		} // for each path segment
		return oCurrent;
	}, // function getValue

	// Function to set value in object via config path
	setValue: function (sConfigPath, oValue, oConfig) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if ((!sConfigPath) || (!oConfig)) {
			return false;
		} // if no path or object
		sConfigPath = sConfigPath.replace(/^\//, '').replace(/\/$/, ''); // remove leading and trailing /
		var aConfigPath = sConfigPath.split('/');
		var iMaxLength = (Array.isArray(aConfigPath)) ? aConfigPath.length : 0;
		if (iMaxLength === 0) {
			return false;
		} // if no path segments
		var oCurrent = oConfig;
		for (var i = 0; i < iMaxLength; i++) {
			if (i === iMaxLength - 1) {
				oCurrent[aConfigPath[i]] = oValue;
				return true;
			} else {
				if (!oCurrent.hasOwnProperty(aConfigPath[i])) {
					oCurrent[aConfigPath[i]] = {};
				} // if not existing
				oCurrent = oCurrent[aConfigPath[i]];
			} // if last or intermediate
		} // for each path segment
		return false;
	}, // function setValue

	// Function to evaluate if value in object via config path
	hasValue: function (sConfigPath, oConfig) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if ((!sConfigPath) || (!oConfig)) {
			return false;
		} // if no path or object
		sConfigPath = sConfigPath.replace(/^\//, '').replace(/\/$/, ''); // remove leading and trailing /
		var aConfigPath = sConfigPath.split('/');
		var iMaxLength = (Array.isArray(aConfigPath)) ? aConfigPath.length : 0;
		if (iMaxLength === 0) {
			return false;
		} // if no path segments or no object
		var oCurrent = oConfig;
		for (var i = 0; i < iMaxLength; i++) {
			if (!oCurrent.hasOwnProperty(aConfigPath[i])) {
				return false;
			} // if property not found
			oCurrent = oCurrent[aConfigPath[i]];
		} // for each path segment
		return true;
	}, // function hasValue

	// Function to delete value in object via config path
	deleteValue: function (sConfigPath, oConfig) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if ((!sConfigPath) || (!oConfig)) {
			return false;
		} // if no path or object
		sConfigPath = sConfigPath.replace(/^\//, '').replace(/\/$/, ''); // remove leading and trailing /
		var aConfigPath = sConfigPath.split('/');
		var iMaxLength = (Array.isArray(aConfigPath)) ? aConfigPath.length : 0;
		if (iMaxLength === 0) {
			return false;
		} // if no path segments
		var oCurrent = oConfig;
		for (var i = 0; i < iMaxLength; i++) {
			if ((gs.nil(oCurrent)) || (!this.isObject(oCurrent)) || (!oCurrent.hasOwnProperty(aConfigPath[i]))) {
				return false;
			} // if property not found
			if (i === iMaxLength - 1) {
				delete oCurrent[aConfigPath[i]];
				return true;
			} else {
				oCurrent = oCurrent[aConfigPath[i]];
			} // if last or intermediate
		} // for each path segment
		return false;
	}, // function deleteValue

	// Simple deep merge without recursion protection etc, using ECMA 5 because running in global
	deepMerge: function (oSource, oMerge, bMergeArrays) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if ((this.isObject(oSource)) && ((!this.isObject(oMerge)))) {
			return oSource;
		} else if ((!this.isObject(oSource)) && ((this.isObject(oMerge)))) {
			return oMerge;
		} else if ((!this.isObject(oSource)) && ((!this.isObject(oMerge)))) {
			return {};
		} // if source and merge
		Object.keys(oMerge).forEach(function (sKey) {
			if ((bMergeArrays) && (this._gtArray.isValidArray(oSource[sKey])) && (this._gtArray.isValidArray(oMerge[sKey]))) {
				oSource[sKey] = this._gtArray.mergeArray(oSource[sKey], oMerge[sKey]);
			} else if ((this.isObject(oSource[sKey])) && (this.isObject(oMerge[sKey]))) {
				oSource[sKey] = this.deepMerge(oSource[sKey], oMerge[sKey], bMergeArrays);
			} else {
				oSource[sKey] = oMerge[sKey];
			} // if key
		}, this); // each key
		return oSource;
	}, // function deepMerge

	// Simple object depth calc (does not check for cyclic objects as this is handled by Rhino: Cyclic {0} value not allowed.)
	getDepth: function (oObj) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if (!this.isObject(oObj)) {
			return -1;
		} else if (Object.keys(oObj).length == 0) {
			return 0;
		} // if no obj
		var aStack = [oObj];
		var aTemp = [];
		var iDepthMax = 0;
		do {
			iDepthMax++;
			aTemp = [];
			aStack.forEach(function (oStackObj) {
				Object.keys(oStackObj).some(function (sKey) {
					if ((this.isObject(oStackObj[sKey])) && (Object.keys(oStackObj[sKey]).length > 0)) {
						aTemp.push(oStackObj[sKey]);
					} // if stacked obj prop is object
				}, this); // each obj key
			}, this); // each stack obj
			aStack = aTemp;
		} while (aStack.length); // while nested objects
		return iDepthMax;
	}, // function getDepth

	parseJSON: function (sJSON) {
		if (!this.checkAccess(gs.getCallerScopeName())) { return; }
		if ((sJSON) && (this._gt.getType(sJSON) == 'string')) {
			try {
				return JSON.parse(sJSON);
			} catch (oEx) {
				// do nothing
			} // catch error
		} // if is string
	}, // function parseJSON

	type: 'GlobalToolsObject',
	version: '1.1.0',
	author: 'Tom Hauri',
	email: 'tom@hauri.biz'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>tom.hauri</sys_created_by>
        <sys_created_on>2023-08-18 10:36:44</sys_created_on>
        <sys_id>52165d601bf47150d5be777d8b4bcbc4</sys_id>
        <sys_mod_count>61</sys_mod_count>
        <sys_name>GlobalToolsObject</sys_name>
        <sys_package display_value="Global Tools" source="a39b8f3697816110b434f5f3a253af25">a39b8f3697816110b434f5f3a253af25</sys_package>
        <sys_policy/>
        <sys_scope display_value="Global Tools">a39b8f3697816110b434f5f3a253af25</sys_scope>
        <sys_update_name>sys_script_include_52165d601bf47150d5be777d8b4bcbc4</sys_update_name>
        <sys_updated_by>tom.hauri</sys_updated_by>
        <sys_updated_on>2026-02-13 09:14:35</sys_updated_on>
    </sys_script_include>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>52165d601bf47150d5be777d8b4bcbc4</id>
        <sys_created_by>tom.hauri</sys_created_by>
        <sys_created_on>2024-11-23 15:07:34</sys_created_on>
        <sys_id>6f2c6221c3c252109ebe8d8dc001311c</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>tom.hauri</sys_updated_by>
        <sys_updated_on>2024-11-23 15:07:34</sys_updated_on>
        <table>sys_script_include</table>
        <use_es_latest>false</use_es_latest>
    </sys_es_latest_script>
</record_update>
